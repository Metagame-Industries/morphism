use clap::Parser;
use morphism_composer::*;

#[derive(Debug, Parser)]
#[command(
    author = "Kachinsky",
    version,
    about = "Manage media albums and their proofs"
)]
pub struct ComposerArgs {
    #[arg(long, help = "The data directory, default ~/.mcd")]
    pub home: Option<std::path::PathBuf>,
    #[clap(subcommand)]
    pub sub: SubCmd,
}

#[derive(Debug, clap::Subcommand)]
pub enum SubCmd {
    #[clap(name = "new", about = "Create a new album")]
    New(NewAlbumCmd),
    #[clap(name = "remove", about = "Remove an album")]
    Remove(RemoveAlbumCmd),
    #[clap(name = "append", about = "Append media file(s) to the album")]
    Append(AppendCmd),
    #[clap(name = "prove", about = "Get PoKF of a video")]
    Prove(ProveCmd),
}

#[derive(Debug, clap::Args)]
pub struct NewAlbumCmd {
    name: String,
}

#[derive(Debug, clap::Args)]
pub struct RemoveAlbumCmd {
    name: String,
}

#[derive(Debug, clap::Args)]
pub struct AppendCmd {
    album: String,
    #[arg(short = 's', long, help = "The source file(s) to append")]
    source: std::path::PathBuf,
    #[arg(long, action = clap::ArgAction::SetTrue, help = "Overwrite the existing file")]
    overwrite: bool,
}

#[derive(Debug, clap::Args)]
pub struct ProveCmd {
    album: String,
    #[arg(
        long,
        short = 'i',
        help = "The video id to prove, in the form of 0x...."
    )]
    id: String,
    #[arg(
        long,
        short = 'f',
        help = "The frames' index generated by the VRF. e.g. [23,321,11]"
    )]
    frames: String,
}

fn main() -> ComposerResult<()> {
    env_logger::init();
    let args = ComposerArgs::parse();
    let home = args.home.unwrap_or(
        dirs::home_dir()
            .map(|h| h.join(".mcd"))
            .expect("Couldn't create default home directory ~/.mcd"),
    );
    if !home.exists() {
        std::fs::create_dir(&home).unwrap();
    }
    match args.sub {
        SubCmd::New(cmd) => {
            Album::new(&home, &cmd.name)?;
            println!("album created: {:?}", &cmd.name);
        }
        SubCmd::Remove(cmd) => {
            let album = Album::find(&home, &cmd.name)?;
            std::fs::remove_dir_all(&album.path).unwrap();
            println!("album removed: {:?}", &cmd.name);
        }
        SubCmd::Append(cmd) => {
            let album = Album::find(&home, &cmd.album)?;
            if cmd.source.is_file() {
                let root = album.append(&cmd.source, cmd.overwrite)?;
                println!("0x{}", hex::encode(<[u8; 32]>::from(root)));
            } else {
                let mut root = xmt::H256::zero();
                for entry in std::fs::read_dir(&cmd.source)? {
                    let entry = entry?;
                    root = album.append(&entry.path(), cmd.overwrite)?;
                }
                println!("0x{}", hex::encode(<[u8; 32]>::from(root)));
            }
        }
        SubCmd::Prove(cmd) => {
            let frames: Vec<u64> =
                serde_json::from_str(&cmd.frames).expect("frames are in the form of [x, y, z]");
            let id: [u8; 32] = hex::decode(&cmd.id[2..])
                .expect("id is in the form of 0x....")
                .try_into()
                .expect("invalid id");
            let album = Album::find(&home, &cmd.album)?;
            let proof = album.get_proof_of_frames(id, &frames)?;
            println!("0x{}", hex::encode(proof));
        }
    }
    Ok(())
}
