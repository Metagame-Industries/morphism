use clap::Parser;
use morphism_composer::*;

#[derive(Debug, Parser)]
#[command(
    author = "Kachinsky",
    version,
    about = "Manage media albums and their proofs"
)]
pub struct ComposerArgs {
    #[arg(long, help = "The data directory, default ~/.mcd")]
    pub home: Option<std::path::PathBuf>,
    #[clap(subcommand)]
    pub sub: SubCmd,
}

#[derive(Debug, clap::Subcommand)]
pub enum SubCmd {
    #[clap(name = "new", about = "Create a new album")]
    New(NewAlbumCmd),
    #[clap(name = "remove", about = "Remove an album")]
    Remove(RemoveAlbumCmd),
    #[clap(name = "append", about = "Append media file(s) to the album")]
    Append(AppendCmd),
    #[clap(name = "prove", about = "Get PoKF of a video")]
    Prove(ProveCmd),
}

#[derive(Debug, clap::Args)]
pub struct NewAlbumCmd {
    name: String,
}

#[derive(Debug, clap::Args)]
pub struct RemoveAlbumCmd {
    name: String,
}

#[derive(Debug, clap::Args)]
pub struct AppendCmd {
    #[arg(short = 'a', long, help = "The album to append to")]
    album: String,
    #[arg(help = "The video source(s) on disk or from internet")]
    source: String,
    #[arg(long, action = clap::ArgAction::SetTrue, help = "Overwrite the existing file")]
    overwrite: bool,
}

#[derive(Debug, clap::Args)]
pub struct ProveCmd {
    #[arg(short = 'a', long, help = "The album which the video belongs to")]
    album: String,
    #[arg(help = "The video id to prove, in the form of 0x....")]
    id: String,
    #[arg(
        long,
        short = 'f',
        help = "The frames' index generated by the VRF. e.g. \"[23, 321, 11]\""
    )]
    frames: String,
}

fn main() -> ComposerResult<()> {
    env_logger::init();
    let args = ComposerArgs::parse();
    let home = args.home.unwrap_or(
        dirs::home_dir()
            .map(|h| h.join(".mcd"))
            .expect("Couldn't create default home directory ~/.mcd"),
    );
    if !home.exists() {
        std::fs::create_dir(&home).unwrap();
    }
    match args.sub {
        SubCmd::New(cmd) => {
            Album::new(&home, &cmd.name)?;
            println!("album created: {:?}", &cmd.name);
        }
        SubCmd::Remove(cmd) => {
            let album = Album::find(&home, &cmd.name)?;
            std::fs::remove_dir_all(&album.path).unwrap();
            println!("album removed: {:?}", &cmd.name);
        }
        SubCmd::Append(cmd) => {
            println!("{:?}", cmd);
            let album = Album::find(&home, &cmd.album)?;
            if let Ok(uri) = uriparse::URI::try_from(cmd.source.as_str()) {
                match uri.scheme() {
                    uriparse::Scheme::HTTP | uriparse::Scheme::HTTPS => {
                        let url = uri.to_string();
                        let rsp = reqwest::blocking::get(&url).expect("downloading failed");
                        let tmp_dir = tempdir::TempDir::new("morphism")?;
                        let path = tmp_dir.path().join(sha256::digest(url.as_bytes()));
                        let mut tmp_file = std::fs::File::create(path.clone())?;
                        std::io::copy(
                            &mut rsp.bytes().expect("malformed video file").as_ref(),
                            &mut tmp_file,
                        )?;
                        let root = album.append(&path, cmd.overwrite)?;
                        println!("0x{}", hex::encode(<[u8; 32]>::from(root)));
                    }
                    uriparse::Scheme::File => {
                        let path = uri.path().to_string();
                        let path = std::path::Path::new(&path);
                        if path.is_file() {
                            let root = album.append(&path, cmd.overwrite)?;
                            println!("0x{}", hex::encode(<[u8; 32]>::from(root)));
                        } else {
                            let mut root = xmt::H256::zero();
                            for entry in std::fs::read_dir(&path)? {
                                let entry = entry?;
                                root = album.append(&entry.path(), cmd.overwrite)?;
                            }
                            println!("0x{}", hex::encode(<[u8; 32]>::from(root)));
                        }
                    }
                    _ => eprintln!("invalid source: {}", cmd.source),
                }
            } else {
                eprintln!("invalid source: {}", cmd.source);
            }
        }
        SubCmd::Prove(cmd) => {
            let frames: Vec<u64> =
                serde_json::from_str(&cmd.frames).expect("frames are in the form of \"[x, y, z]\"");
            let id: [u8; 32] = hex::decode(&cmd.id[2..])
                .expect("id is in the form of 0x....")
                .try_into()
                .expect("invalid id");
            let album = Album::find(&home, &cmd.album)?;
            let proof = album.get_proof_of_frames(id, &frames)?;
            println!("0x{}", hex::encode(proof));
        }
    }
    Ok(())
}
